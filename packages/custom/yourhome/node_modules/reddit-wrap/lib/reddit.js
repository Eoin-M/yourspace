var request = require('request');

// config values required for app-only auth
var required_for_app_auth = [
  'consumer_key',
  'consumer_secret'
];

// config values required for user auth (superset of app-only auth)
var required_for_user_auth = required_for_app_auth.concat([
  'access_token',
  'refresh_token'
]);

var Reddit = function(config){
	if (!(this instanceof Reddit)) {
    return new Reddit(config);
  }

  var self = this;
  if(config != null){
	  var credentials = {
		consumer_key        : config.consumer_key,
		consumer_secret     : config.consumer_secret,
		// access_token and access_token_secret only required for user auth
		access_token        : config.access_token,
		refresh_token       : config.refresh_token,
		// flag indicating whether requests should be made with application-only auth
		app_only_auth       : config.app_only_auth,
	  };
	  this.config = config;
	}
}

Reddit.prototype.get = function (path, params, callback) {
  path = 'https://reddit.com' + path + '.json';
  return this.request('GET', path, params, callback);
}

Reddit.prototype.post = function (path, params, callback) {
  path = 'https://reddit.com' + path + '.json';
  return this.request('POST', path, params, callback);
}

Reddit.prototype.getOAuth = function (path, params, callback) {
  path = 'https://oauth.reddit.com' + path;
  return this.request('GET', path, params, callback);
}

Reddit.prototype.postOAuth = function (path, params, callback) {
  path = 'https://oauth.reddit.com' + path;
  return this.request('POST', path, params, callback);
}

Reddit.prototype.request = function (method, path, params, callback) {
  var self = this;
  //assert(method == 'GET' || method == 'POST');
  // if no `params` is specified but a callback is, use default params
  if (typeof params === 'function') {
    callback = params;
    params = {};
  }

  self._buildReqOpts(method, path, params, function (err, reqOpts) {
    if (err) {
      callback(err, null, null);
      return;
    }

    //var twitOptions = (params && params.twit_options) || {};

    process.nextTick(function () {
      // ensure all HTTP i/o occurs after the user has a chance to bind their event handlers
      self._doRestApiRequest(method, path, params, reqOpts, callback);
    });
  });

  return self;
}

Reddit.prototype._buildReqOpts = function (method, path, params, callback) {
  var self = this;
  if (!params) {
    params = {};
  }
  // clone `params` object so we can modify it without modifying the user's reference
  //var paramsClone = JSON.parse(JSON.stringify(params));
  // convert any arrays in `paramsClone` to comma-seperated strings
  //var finalParams = this.normalizeParams(paramsClone);
  //delete finalParams.twit_options;

  // the options object passed to `request` used to perform the HTTP request
  var reqOpts = {
    headers: {
      'User-Agent'    : 'reddit-wrap',
    }
  };
  
  if(self.config)  reqOpts.headers['Authorization'] = 'bearer ' + self.config.access_token;
  
  if(params) {
	  reqOpts.params = params;
  }

  /*try {
    // finalize the `path` value by building it using user-supplied params
    path = helpers.moveParamsIntoPath(finalParams, path)
  } catch (e) {
    callback(e, null, null);
    return;
  }*/

  // This is a REST API request.
  
  /*if (FORMDATA_PATHS.indexOf(path) !== -1) {
    reqOpts.headers['Content-type'] = 'multipart/form-data';
    reqOpts.form = finalParams;
     // set finalParams to empty object so we don't append a query string
    // of the params
    finalParams = {};
  } else {
    reqOpts.headers['Content-type'] = 'application/json';
  }*/

  /*if (Object.keys(finalParams).length) {
    // not all of the user's parameters were used to build the request path
    // add them as a query string
    var qs = helpers.makeQueryString(finalParams);
    reqOpts.url += '?' + qs;
  }*/

  /*if (!self.config.app_only_auth) {
    // with user auth, we can just pass an oauth object to requests
    // to have the request signed
    reqOpts.oauth = {
      consumer_key: self.config.consumer_key,
      consumer_secret: self.config.consumer_secret,
      token: self.config.access_token,
      token_secret: self.config.access_token_secret,
    }

    callback(null, reqOpts);
    return;
  } else {
    // we're using app-only auth, so we need to ensure we have a bearer token
    // Once we have a bearer token, add the Authorization header and return the fully qualified `reqOpts`.
    self._getBearerToken(function (err, bearerToken) {
      if (err) {
        callback(err, null)
        return
      }

      reqOpts.headers['Authorization'] = 'Bearer ' + bearerToken;
      callback(null, reqOpts)
      return
    })
  }*/
  callback(null, reqOpts);
}

Reddit.prototype._doRestApiRequest = function (method, path, params, reqOpts, callback) {
  request({
    url: path,
    method: method,
    headers: reqOpts.headers,
	form: reqOpts.params
  }, function(error, response, body){
    callback(error, JSON.parse(body), response);
  });
};

module.exports = Reddit;